---
description: Complete workflow for integrating shadcnblocks.com components into the Sanity-powered application
globs: **/*.{ts,tsx,js,jsx}
alwaysApply: false
---

## Integrating shadcnblocks.com Components

When the user provides a new component from shadcnblocks.com (React code + screenshot), follow this complete workflow to integrate it into the application.

### What the User Provides

The user will typically provide:

1. **Screenshot** of the component from shadcnblocks.com
2. **React code** for the component
3. **Component documentation** showing props and their types
4. **(Optional)** Specific instructions about which document types to add it to

### Understanding Component Documentation

When provided with props documentation, analyze:

**Prop Structure:**

```typescript
interface ComponentProps {
  title?: string; // Optional text → schema: string
  description: string; // Required text → schema: string with validation
  image?: ImageProps; // Optional image → schema: image
  items: ItemProps[]; // Array → decide inline vs reusable
  variant?: 'default' | 'compact'; // Enum → schema: string with options.list
}
```

**Mapping Props to Schema:**

- `string | undefined` → `{ type: 'string' }` (optional)
- `string` (required) → `{ type: 'string', validation: (rule) => rule.required() }`
- `string[]` → `{ type: 'array', of: [{ type: 'string' }] }`
- `ImageProps` → `{ type: 'image', options: { hotspot: true } }`
- `LinkProps` → `{ type: 'link' }`
- `"variant1" | "variant2"` → `{ type: 'string', options: { list: [...] } }`
- `ItemProps[]` → See "Handling Repeating Items" below

**Common Patterns:**

- Props with "?" are optional in schema (no required validation)
- Array props need decision: inline object vs reference
- Union types become `options.list` in schema
- Complex nested objects may need separate schema types

### Prerequisites

Before starting, use Context7 MCP to:

- Fetch latest Sanity documentation for schema patterns
- Fetch latest Next.js documentation for component patterns
- Review shadcnblocks documentation if needed

### Workflow Overview

The integration process requires **5 main steps** in this order:

1. **Create Schema Files** (Sanity Studio)
2. **Register Schema Types** (schema.ts)
3. **Create Query Files** (GROQ queries)
4. **Create React Components** (Front-end)
5. **Wire Everything Together** (index files)

---

## Step 1: Create Schema Files

### 1.1 Analyze Component Structure

From the provided React code, screenshot, and documentation, determine:

- Is this a **parent block** (contains child components) or **standalone block**?
- What fields are present? (text, images, links, arrays, etc.)
- What visual customization options exist? (colors, padding, layout variants)
- **Analyze the props documentation** to understand:
  - Required vs optional props
  - Prop types and their structure
  - Default values
  - Any array props that represent repeating items

#### Handling Repeating Items

When components have **array props** for items (e.g., `items`, `features`, `testimonials`, `team`):

**Option 1: Inline Items (Recommended for simple items)**

- Create an inline object type within the parent schema
- Use when items are specific to this component only
- Example: Simple feature lists, step items, FAQ items

**Option 2: Reusable Items (Recommended for complex items)**

- Create a separate schema type (document or object)
- Use when items could be referenced by multiple components
- Use `type: "reference"` for document references
- Use `type: "{item-type}"` for object references
- Example: Testimonials, team members, products that might be used in multiple places

**Decision Criteria:**

- Simple items with 2-3 fields → Inline
- Complex items with many fields → Separate schema type
- Items used in multiple components → Separate schema type (reusable)
- Items specific to one component → Inline

### 1.2 Create Schema Type File(s)

#### Location Pattern:

- Parent blocks: `/sanity/schemas/blocks/{category}/{component-name}.ts`
- Child components: `/sanity/schemas/blocks/{category}/{child-name}.ts`
- Standalone blocks: `/sanity/schemas/blocks/{component-name}.ts`

**Categories include:** hero, grid, split, carousel, timeline, cta, logo-cloud, forms

#### Schema File Template (Standalone Block):

```typescript
import { defineField, defineType } from 'sanity';
import { IconName } from 'lucide-react'; // Choose appropriate icon

export default defineType({
  name: 'component-name', // kebab-case, matches filename
  type: 'object',
  title: 'Component Name', // Human-readable
  description: 'Brief description of what this component does',
  icon: IconName,
  fields: [
    // Common fields (use as needed):
    defineField({
      name: 'padding',
      type: 'section-padding',
    }),
    defineField({
      name: 'colorVariant',
      type: 'color-variant',
      description: 'Select a background color variant',
    }),
    defineField({
      name: 'tagLine',
      type: 'string',
    }),
    defineField({
      name: 'title',
      type: 'string',
    }),
    defineField({
      name: 'body',
      type: 'block-content',
    }),
    defineField({
      name: 'image',
      type: 'image',
      options: { hotspot: true },
      fields: [
        {
          name: 'alt',
          type: 'string',
          title: 'Alternative Text',
        },
      ],
    }),
    defineField({
      name: 'link',
      type: 'link',
      description:
        'Link to a page or external URL. Leave empty to hide the link.',
    }),
    defineField({
      name: 'links',
      type: 'array',
      of: [{ type: 'link' }],
      validation: (rule) => rule.max(2), // Adjust as needed
    }),
  ],
  preview: {
    select: {
      title: 'title', // Adjust based on available fields
    },
    prepare({ title }) {
      return {
        title: 'Component Name',
        subtitle: title || 'No Title',
      };
    },
  },
});
```

#### Schema File Template (Block with Inline Items):

```typescript
import { defineField, defineType } from 'sanity';
import { IconName } from 'lucide-react';

export default defineType({
  name: 'component-with-items',
  type: 'object',
  title: 'Component with Items',
  description: 'Component with repeating inline items',
  icon: IconName,
  fields: [
    defineField({
      name: 'padding',
      type: 'section-padding',
    }),
    defineField({
      name: 'colorVariant',
      type: 'color-variant',
    }),
    defineField({
      name: 'title',
      type: 'string',
    }),
    defineField({
      name: 'items',
      type: 'array',
      of: [
        {
          type: 'object',
          fields: [
            defineField({ name: 'title', type: 'string' }),
            defineField({ name: 'description', type: 'text' }),
            defineField({
              name: 'icon',
              type: 'string',
              description: 'Icon name from lucide-react',
            }),
            defineField({
              name: 'image',
              type: 'image',
              options: { hotspot: true },
              fields: [{ name: 'alt', type: 'string' }],
            }),
          ],
          preview: {
            select: {
              title: 'title',
              subtitle: 'description',
            },
          },
        },
      ],
    }),
  ],
  preview: {
    select: {
      title: 'title',
    },
    prepare({ title }) {
      return {
        title: 'Component with Items',
        subtitle: title || 'No Title',
      };
    },
  },
});
```

#### Schema File Template (Parent Block with Children):

```typescript
import { defineType, defineField } from 'sanity';
import { IconName } from 'lucide-react';

export default defineType({
  name: 'parent-row',
  type: 'object',
  title: 'Parent Row',
  description: 'Parent block with multiple child component variants',
  icon: IconName,
  fields: [
    defineField({
      name: 'padding',
      type: 'section-padding',
    }),
    defineField({
      name: 'colorVariant',
      type: 'color-variant',
      description: 'Select a background color variant',
    }),
    // Layout-specific fields (e.g., gap, columns)
    defineField({
      name: 'columns',
      type: 'array',
      of: [
        { type: 'child-component-1' },
        { type: 'child-component-2' },
        { type: 'child-component-3' },
      ],
      validation: (rule) => rule.max(4), // Adjust based on design
      options: {
        insertMenu: {
          views: [
            {
              name: 'grid',
              previewImageUrl: (block) => `/sanity/preview/${block}.jpg`,
            },
            { name: 'list' },
          ],
        },
      },
    }),
  ],
  preview: {
    select: {
      title0: 'columns.0.title',
      title1: 'columns.1.title',
    },
    prepare({ title0, title1 }) {
      return {
        title: 'Parent Row',
        subtitle: title0 || title1 || 'No Title',
      };
    },
  },
});
```

### 1.3 Key Schema Principles

**CRITICAL RULES:**

- ALWAYS use `defineType`, `defineField`, and `defineArrayMember`
- NEVER hardcode content values
- ALWAYS include an `icon` from `lucide-react`
- ALWAYS provide meaningful `preview` configuration
- Use `section-padding` and `color-variant` for consistent styling
- Use `block-content` for rich text
- Use `link` type for buttons/links (includes internal/external handling)
- Use `options.hotspot: true` for images
- Use `validation` rules appropriately
- Use `initialValue` for boolean fields

**Field Type Guidelines:**

- Text content → `string` or `text` (multi-line)
- Rich text → `block-content`
- Images → `image` with alt field
- Links/Buttons → `link` (handles internal/external)
- Multiple links → `array` of `link`
- Boolean toggles → `boolean` with `initialValue`
- Enums → `string` with `options.list`
- Child components → `array` of object types

---

## Step 2: Register Schema Types

### 2.1 Import Schema in `/sanity/schema.ts`

```typescript
// Import your new schema files
import componentName from './schemas/blocks/{category}/{component-name}';
import childComponent from './schemas/blocks/{category}/{child-name}';

export const schema: { types: SchemaTypeDefinition[] } = {
  types: [
    // ... existing types
    componentName,
    childComponent, // If applicable
  ],
};
```

**Order:** Documents first, shared objects, then blocks

### 2.2 Add to Page Schema (if applicable)

Edit `/sanity/schemas/documents/page.ts`:

```typescript
defineField({
  name: "blocks",
  type: "array",
  group: "content",
  of: [
    // ... existing blocks
    { type: "component-name" }, // Add your new block
  ],
  options: {
    insertMenu: {
      groups: [
        // ... existing groups
        {
          name: "category-name", // e.g., "testimonials"
          title: "Category Name",
          of: ["component-name"],
        },
      ],
      views: [
        {
          name: "grid",
          previewImageUrl: (block) => `/sanity/preview/${block}.jpg`,
        },
        { name: "list" },
      ],
    },
  },
}),
```

**Note:** If user requests adding to other document types (e.g., post), add there as well.

---

## Step 3: Create Query Files

### 3.1 Create Query Fragment File(s)

#### Location Pattern:

- Parent blocks: `/sanity/queries/{category}/{component-name}.ts`
- Child components: `/sanity/queries/{category}/{child-name}.ts`
- Standalone blocks: `/sanity/queries/{component-name}.ts`

#### Query Template (Standalone Block):

```typescript
import { groq } from 'next-sanity';
import { linkQuery } from '../shared/link';
import { imageQuery } from '../shared/image';
import { bodyQuery } from '../shared/body';

// @sanity-typegen-ignore
export const componentNameQuery = groq`
  _type == "component-name" => {
    _type,
    _key,
    padding,
    colorVariant,
    tagLine,
    title,
    body[]{
      ${bodyQuery}
    },
    image{
      ${imageQuery}
    },
    link{
      ${linkQuery}
    },
    links[]{
      ${linkQuery}
    },
  }
`;
```

#### Query Template (Parent Block):

```typescript
import { groq } from 'next-sanity';
import { childComponent1Query } from './child-component-1';
import { childComponent2Query } from './child-component-2';

// @sanity-typegen-ignore
export const parentRowQuery = groq`
  _type == "parent-row" => {
    _type,
    _key,
    padding,
    colorVariant,
    columns[]{
      ${childComponent1Query},
      ${childComponent2Query},
    },
  }
`;
```

#### Query Template (Child Component):

```typescript
import { groq } from 'next-sanity';
import { linkQuery } from '../shared/link';
import { imageQuery } from '../shared/image';

// @sanity-typegen-ignore
export const childComponentQuery = groq`
  _type == "child-component" => {
    _type,
    _key,
    title,
    description,
    image{
      ${imageQuery}
    },
  }
`;
```

### 3.2 Query Principles

**CRITICAL RULES:**

- ALWAYS use `groq` tag from "next-sanity"
- ALWAYS include `_type` and `_key`
- ALWAYS use shared query fragments (`linkQuery`, `imageQuery`, `bodyQuery`)
- ALWAYS add `// @sanity-typegen-ignore` comment
- Use conditional query pattern: `_type == "name" => { ... }`
- Query every field defined in schema (no hardcoding)

**Shared Query Fragments Available:**

- `linkQuery` - handles internal/external links
- `imageQuery` - fetches image with metadata, lqip, dimensions
- `bodyQuery` - fetches portable text with nested links/images

### 3.3 Update Page Query

Edit `/sanity/queries/page.ts`:

```typescript
import { componentNameQuery } from './{category}/{component-name}';

export const PAGE_QUERY = groq`
  *[_type == "page" && slug.current == $slug][0]{
    blocks[]{
      // ... existing queries
      ${componentNameQuery},
    },
    // ... rest of query
  }
`;
```

---

## Step 4: Create React Components

### 4.1 Create Component File(s)

#### Location Pattern:

- Parent blocks: `/components/blocks/{category}/{component-name}.tsx`
- Child components: `/components/blocks/{category}/{child-name}.tsx`
- Standalone blocks: `/components/blocks/{component-name}.tsx`

#### Component Template (Standalone Block):

```tsx
import { PAGE_QUERYResult } from '@/sanity.types';
import { stegaClean } from 'next-sanity';
import { Button } from '@/components/ui/button';
import Link from 'next/link';
import Image from 'next/image';
import { urlFor } from '@/sanity/lib/image';
import PortableTextRenderer from '@/components/portable-text-renderer';
import TagLine from '@/components/ui/tag-line';
import SectionContainer from '@/components/ui/section-container';

type Block = NonNullable<NonNullable<PAGE_QUERYResult>['blocks']>[number];
type ComponentNameBlock = Extract<Block, { _type: 'component-name' }>;

export default function ComponentName({
  padding,
  colorVariant,
  tagLine,
  title,
  body,
  image,
  link,
  links,
}: ComponentNameBlock) {
  const color = stegaClean(colorVariant);

  return (
    <SectionContainer color={color} padding={padding}>
      {/* Paste and adapt the React code from shadcnblocks.com here */}
      {/* Replace all hardcoded values with props */}
      <div className="...">
        {tagLine && <TagLine title={tagLine} element="h2" />}
        {title && <h2 className="...">{title}</h2>}
        {body && <PortableTextRenderer value={body} />}
        {image && image.asset?._id && (
          <Image
            src={urlFor(image).url()}
            alt={image.alt || ''}
            width={image.asset?.metadata?.dimensions?.width || 800}
            height={image.asset?.metadata?.dimensions?.height || 800}
            placeholder={image?.asset?.metadata?.lqip ? 'blur' : undefined}
            blurDataURL={image?.asset?.metadata?.lqip || ''}
            quality={100}
          />
        )}
        {link?.href && (
          <Button variant={stegaClean(link?.buttonVariant)} asChild>
            <Link href={link.href} target={link.target ? '_blank' : undefined}>
              {link.title}
            </Link>
          </Button>
        )}
      </div>
    </SectionContainer>
  );
}
```

#### Component Template (Parent Block):

```tsx
import { cn } from '@/lib/utils';
import SectionContainer from '@/components/ui/section-container';
import { stegaClean } from 'next-sanity';
import { PAGE_QUERYResult } from '@/sanity.types';
import ChildComponent1 from './child-component-1';
import ChildComponent2 from './child-component-2';

type Block = NonNullable<NonNullable<PAGE_QUERYResult>['blocks']>[number];
type ParentRow = Extract<Block, { _type: 'parent-row' }>;
type ColumnType = NonNullable<NonNullable<ParentRow['columns']>[number]>;

const componentMap: {
  [K in ColumnType['_type']]: React.ComponentType<
    Extract<ColumnType, { _type: K }>
  >;
} = {
  'child-component-1': ChildComponent1,
  'child-component-2': ChildComponent2,
};

export default function ParentRow({
  padding,
  colorVariant,
  columns,
}: ParentRow) {
  const color = stegaClean(colorVariant);

  return (
    <SectionContainer color={color} padding={padding}>
      {columns && columns?.length > 0 && (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {columns.map((column) => {
            const Component = componentMap[column._type];
            if (!Component) {
              console.warn(
                `No component implemented for column type: ${column._type}`
              );
              return <div data-type={column._type} key={column._key} />;
            }
            return (
              <Component {...(column as any)} color={color} key={column._key} />
            );
          })}
        </div>
      )}
    </SectionContainer>
  );
}
```

#### Component Template (Child Component):

```tsx
import { PAGE_QUERYResult } from '@/sanity.types';
import Image from 'next/image';
import { urlFor } from '@/sanity/lib/image';

type Block = NonNullable<NonNullable<PAGE_QUERYResult>['blocks']>[number];
type ParentRow = Extract<Block, { _type: 'parent-row' }>;
type ChildComponent = Extract<
  NonNullable<ParentRow['columns']>[number],
  { _type: 'child-component' }
>;

interface ChildComponentProps extends ChildComponent {
  color?: string; // Passed from parent
}

export default function ChildComponent({
  title,
  description,
  image,
  color,
}: ChildComponentProps) {
  return (
    <div className="...">
      {/* Adapt shadcnblocks code here */}
      {title && <h3>{title}</h3>}
      {description && <p>{description}</p>}
      {image && image.asset?._id && (
        <Image
          src={urlFor(image).url()}
          alt={image.alt || ''}
          width={image.asset?.metadata?.dimensions?.width || 600}
          height={image.asset?.metadata?.dimensions?.height || 400}
        />
      )}
    </div>
  );
}
```

### 4.2 Component Principles

**CRITICAL RULES:**

- ALWAYS extract proper TypeScript types from `PAGE_QUERYResult`
- ALWAYS use `stegaClean()` for enum values (e.g., colorVariant, buttonVariant)
- NEVER hardcode content - use props from Sanity
- Use TailwindCSS classes from the shadcnblocks code
- Wrap top-level blocks in `SectionContainer` (handles padding/color)
- Use helper components:
  - `PortableTextRenderer` for rich text
  - `TagLine` for tag lines
  - `urlFor()` for image URLs
  - `Button` from shadcn/ui
- Use proper Next.js `Image` component with metadata
- Use functional components with proper props destructuring
- Include proper null checks and conditional rendering

**Image Pattern:**

```tsx
{
  image && image.asset?._id && (
    <Image
      src={urlFor(image).url()}
      alt={image.alt || ''}
      width={image.asset?.metadata?.dimensions?.width || 800}
      height={image.asset?.metadata?.dimensions?.height || 800}
      placeholder={image?.asset?.metadata?.lqip ? 'blur' : undefined}
      blurDataURL={image?.asset?.metadata?.lqip || ''}
      quality={100}
      className="..."
    />
  );
}
```

**Link/Button Pattern:**

```tsx
{
  link?.href && (
    <Button variant={stegaClean(link?.buttonVariant)} size="lg" asChild>
      <Link href={link.href} target={link.target ? '_blank' : undefined}>
        {link.title}
      </Link>
    </Button>
  );
}
```

**Links Array Pattern:**

```tsx
{
  links && links.length > 0 && (
    <div className="flex gap-4">
      {links.map((link) => (
        <Button
          key={link.title}
          variant={stegaClean(link?.buttonVariant)}
          asChild
        >
          <Link
            href={link.href || '#'}
            target={link.target ? '_blank' : undefined}
          >
            {link.title}
          </Link>
        </Button>
      ))}
    </div>
  );
}
```

---

## Step 5: Wire Everything Together

### 5.1 Update Block Index File

Edit `/components/blocks/index.tsx`:

```typescript
import { PAGE_QUERYResult } from '@/sanity.types';
import ComponentName from '@/components/blocks/{category}/{component-name}';
// ... other imports

type Block = NonNullable<NonNullable<PAGE_QUERYResult>['blocks']>[number];

const componentMap: {
  [K in Block['_type']]: React.ComponentType<Extract<Block, { _type: K }>>;
} = {
  // ... existing mappings
  'component-name': ComponentName,
};

export default function Blocks({ blocks }: { blocks: Block[] }) {
  return (
    <>
      {blocks?.map((block) => {
        const Component = componentMap[block._type];
        if (!Component) {
          console.warn(
            `No component implemented for block type: ${block._type}`
          );
          return <div data-type={block._type} key={block._key} />;
        }
        return <Component {...(block as any)} key={block._key} />;
      })}
    </>
  );
}
```

### 5.2 Create Preview Image

**Location:** `/public/sanity/preview/{component-name}.jpg`

**CRITICAL:** The preview image is what users see in Sanity Studio's insert menu, making it easy to visually identify and select components.

**Process:**

1. Use the screenshot provided by the user (or take one from shadcnblocks.com)
2. Crop/resize if needed to show the component clearly
3. Save as `.jpg` format in `/public/sanity/preview/`
4. Name MUST match the schema `name` field exactly (kebab-case)
   - Schema name: `hero-3` → File: `hero-3.jpg`
   - Schema name: `testimonial-grid` → File: `testimonial-grid.jpg`

**For Parent-Child Components:**

- Parent block: `{parent-name}.jpg` (e.g., `split-row.jpg`)
- Child components: `{child-name}.jpg` (e.g., `split-content.jpg`, `split-image.jpg`)
- Each child needs its own preview image for the insertMenu

**Image Specifications:**

- Format: JPEG (`.jpg`)
- Recommended dimensions: 800x600px or similar aspect ratio
- Show the component in a representative state (with sample content)
- Keep file size reasonable (< 200KB)

**This image appears in:**

- Sanity Studio block insert menu (grid view)
- Child component selection within parent blocks

---

## Step 6: Generate Types and Test

### 6.1 Regenerate Sanity Types

Run the following command to generate TypeScript types:

```bash
pnpm typegen
```

This runs:

1. `rm -rf schema.json` - removes old schema
2. `sanity schema extract` - extracts new schema
3. `sanity typegen generate` - generates TypeScript types

### 6.2 Verify Integration

**In Sanity Studio:**

1. Navigate to `http://localhost:3000/studio`
2. Open a page document
3. Add your new block component
4. Fill in all fields
5. Publish

**In Front-end:**

1. Navigate to the page where you added the component
2. Verify component renders correctly
3. Check that all fields are displayed
4. Verify Tailwind styles are applied
5. Test responsive behavior

---

## Special Cases

### Case 1: Creating New Content Types (e.g., Testimonial, Team Member)

If the user asks to create a new document type (not a block):

1. **Create document schema:**

   - Location: `/sanity/schemas/documents/{document-name}.ts`
   - Use `type: "document"` (not "object")
   - Include SEO fields if needed
   - Add `orderRankField` if ordering is needed

2. **Create queries:**

   - Single document: `DOCUMENT_QUERY`
   - List of documents: `DOCUMENTS_QUERY`
   - Slugs for static params: `DOCUMENTS_SLUGS_QUERY`

3. **Create pages if needed:**

   - `/app/(main)/{document-type}/[slug]/page.tsx`
   - Implement `generateStaticParams()`
   - Implement `generateMetadata()`

4. **Reference in blocks:**
   - Use `type: "reference"` in block schemas
   - Add `to: [{ type: "document-name" }]`
   - Query with `document->{...fields}`

### Case 2: Adding Component to Multiple Parent Blocks

If a child component should be available in multiple parents:

1. Register the child component in each parent's schema `of` array
2. Import the child query in each parent's query file
3. Add to each parent's `componentMap` in React

### Case 3: Complex Nested Structures

For deeply nested components (e.g., accordion > items > content):

1. Create schema for each level (parent, child, grandchild)
2. Create queries for each level
3. Create components for each level
4. Use nested `componentMap` objects in parent components

### Case 4: Components with Repeating Items

When a component has an array of items (e.g., features, testimonials, team members), decide between inline vs reusable:

#### Inline Items Example (Simple Feature List):

**Schema:**

```typescript
defineField({
  name: 'features',
  type: 'array',
  of: [
    {
      type: 'object',
      fields: [
        { name: 'title', type: 'string' },
        { name: 'description', type: 'text' },
        { name: 'icon', type: 'string' },
      ],
    },
  ],
}),
```

#### Reusable Items Example (Testimonials):

**1. Create document schema** (`/sanity/schemas/documents/testimonial.ts`):

```typescript
export default defineType({
  name: 'testimonial',
  type: 'document',
  fields: [
    defineField({ name: 'quote', type: 'text' }),
    defineField({ name: 'author', type: 'string' }),
    defineField({ name: 'role', type: 'string' }),
    defineField({ name: 'avatar', type: 'image' }),
    defineField({ name: 'company', type: 'string' }),
  ],
});
```

**2. Reference in block schema:**

```typescript
defineField({
  name: 'testimonials',
  type: 'array',
  of: [{ type: 'reference', to: [{ type: 'testimonial' }] }],
}),
```

**3. Query with dereferencing:**

```typescript
testimonials[]->{
  _id,
  quote,
  author,
  role,
  avatar{
    ${imageQuery}
  },
  company
}
```

**4. Type extraction in component:**

```typescript
type Testimonial = NonNullable<NonNullable<Block['testimonials']>[number]>;
```

---

## Checklist Template

When integrating a new shadcnblocks.com component, complete this checklist:

### Schema Layer

- [ ] Analyzed component props documentation to understand structure
- [ ] Decided on inline vs reusable items for any array fields
- [ ] Created schema file(s) in `/sanity/schemas/blocks/{category}/`
- [ ] Included all fields (no hardcoded content)
- [ ] Added icon from lucide-react
- [ ] Configured preview
- [ ] Used proper field types (section-padding, color-variant, link, etc.)
- [ ] For inline items: added proper preview configuration
- [ ] For reusable items: created separate document/object schema
- [ ] Registered in `/sanity/schema.ts`
- [ ] Added to page schema blocks array (or other document type)
- [ ] Added to insertMenu groups

### Query Layer

- [ ] Created query file(s) in `/sanity/queries/{category}/`
- [ ] Used groq tag and @sanity-typegen-ignore
- [ ] Included \_type and \_key
- [ ] Used shared query fragments (linkQuery, imageQuery, bodyQuery)
- [ ] Queried all schema fields
- [ ] Updated PAGE_QUERY in `/sanity/queries/page.ts`

### Component Layer

- [ ] Created component file(s) in `/components/blocks/{category}/`
- [ ] Extracted proper TypeScript types from PAGE_QUERYResult
- [ ] Wrapped in SectionContainer (for top-level blocks)
- [ ] Used stegaClean for enum values
- [ ] Replaced all hardcoded content with props
- [ ] Used urlFor() for images
- [ ] Used proper Image component with metadata
- [ ] Used Button and Link components properly
- [ ] Added null checks and conditional rendering
- [ ] Adapted shadcnblocks code with Tailwind classes

### Integration Layer

- [ ] Updated `/components/blocks/index.tsx` componentMap
- [ ] Imported component in index.tsx
- [ ] Saved screenshot to `/public/sanity/preview/{name}.jpg`
- [ ] Screenshot name matches schema name exactly (kebab-case)
- [ ] For parent-child: created preview images for each child component
- [ ] Ran `pnpm typegen` to regenerate types
- [ ] Tested in Sanity Studio
- [ ] Verified preview image appears in insert menu
- [ ] Tested on front-end
- [ ] Verified responsive behavior
- [ ] Verified all fields are editable and display correctly

---

## Common Patterns Reference

### Available Shared Schema Types

- `section-padding` - top/bottom padding toggles
- `color-variant` - background color variants
- `button-variant` - button style variants
- `link` - internal/external link with button variant
- `block-content` - portable text (rich text)
- `image` - image with alt text and metadata

### Available Shared Query Fragments

- `linkQuery` - handles internal/external link resolution
- `imageQuery` - fetches image with metadata, lqip, dimensions
- `bodyQuery` - fetches portable text with nested links/images

### Available UI Components

- `SectionContainer` - wrapper with padding and color
- `TagLine` - styled tag line component
- `PortableTextRenderer` - renders portable text
- `Button` - shadcn/ui button
- `Card` - shadcn/ui card
- `Badge` - shadcn/ui badge
- `Accordion` - shadcn/ui accordion

### Image Helper

- `urlFor(image)` - generates optimized image URL from Sanity image object

### Utility Functions

- `stegaClean(value)` - cleans Sanity encoded values for comparison
- `cn(...classes)` - conditional className utility (clsx + tailwind-merge)

---

## When to Ask vs Execute

**Ask the user when:**

- Component structure is ambiguous (parent/child unclear)
- Multiple valid implementations exist
- Need clarification on which document types to add component to
- Unsure about field types or validation rules

**Execute immediately when:**

- Component structure is clear from the React code
- All necessary information is provided
- Following established patterns in the codebase
- Standard shadcnblocks component integration

---

## Documentation References

When implementing:

1. Use Context7 to fetch latest Sanity schema documentation
2. Use Context7 to fetch Next.js App Router documentation
3. Refer to existing components in the codebase as examples
4. Check shadcnblocks documentation for component-specific details
